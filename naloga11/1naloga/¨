import numpy as np
from numpy.linalg import inv
from numpy import linalg as LA

#Podatki imajo 7 stolpcev
data = np.loadtxt("../kalman_cartesian_data.dat", delimiter=" ")

t = data[:,0]
pozicija = np.c_[data[:,1], data[:,2]]
hitrost = np.c_[data[:,3], data[:,4]]
pospesek = np.c_[data[:,5], data[:,6]]

# Zacetni pogoji
vx0, vy0 = hitrost[0,0], hitrost[0,1]   # Hitrost
x0, y0 = pozicija[0,0], pozicija[0,1]     # Pozicija
dt = 1.783                  # Casovni korak

# Napake 
sigma_x = 25
sigma_a = 0.05

def sigma_v(v):
    return max(1/3.6, LA.norm(v)*0.01)

# Merske napake 
Q = np.diag([0, 0, sigma_a**2*dt**2, sigma_a**2*dt**2])
F = np.array([[1, 0, dt, 0], 
              [0, 1, 0, dt],
              [0, 0, 1, 0],
              [0, 0, 0, 1],])

# Nardim vec razlicnih okenskih funkcij
H1 = np.zeros(shape=(4,4))
H2 = np.array([[0,0,0,0],
               [0,0,0,0],
               [0,0,1,0],
               [0,0,0,1]])
H3 = np.identity(4)

def sum_meritev(v):
    sigmav = sigma_v(v)
    return np.diag([sigma_x**2, sigma_x**2, sigmav**2, sigmav**2])
 
def napoved2d(x, v, t, a, c):
    X = np.array([x[0], x[1], v[0], v[1]])
    B = np.array([[0.5*t**2, 0],
                  [0, 0.5*t**2],
                  [t, 0],
                  [0, t]])
    X_prime = F.dot(X) + B.dot(a) + c
    return X_prime

# Zacetna kovarianca matrika
#sigmav0 = sigma_v([vx0,vy0])
#P = np.diag([sigma_x**2, sigma_x**2, sigmav0**2, sigmav0**2])
P =  np.ones((4, 4))

# Zacetni vektor stanja 
trajektorija = pozicija[0]

x = np.ones(4)

#print("#Vzamem novo v in s na vsakem koraku: ")
#print("#Vzamem novo v na vsakem koraku in s na vsakem 5.: ")
print("#Vzamem novo v na vsakem 5. koraku in s na vsakem 10.: ")
n = len(t)

for i in range(1,n):
    c = np.array([0, 0, pospesek[i,0], pospesek[i,1]])

    # Nova napoved:
    x = napoved2d(x[0:2], x[2:4], dt, pospesek[i], c)
    P = np.dot(np.dot(F, P), F.T) + Q

    # Podatkov ne upostevam na vsakem koraku
    H = H1
    z = np.zeros(4)
    if i%5 == 0:            # Hitrost dobimo vsak 5. korak
        if i%10 == 0:       # Pozicijo dobimo vsak 10. korak
            H = H3
            z = np.concatenate((pozicija[i], hitrost[i]))
        else:
            H = H2
            z = np.concatenate(([0,0], hitrost[i]))
    # Vstavim podatke v Y in R
    y = z - np.dot(H,x)
    R = sum_meritev(x[2:4])                      #R je odvisen od hitrosti

    # Kalman ojacevalni faktor
    S = np.dot(H, np.dot(P, H.T)) + R
    K = np.dot( np.dot(P, H.T), LA.inv(S))

    # Izboljsana napoved
    x = x + np.dot(K, y)
    P = np.dot(np.dot(np.identity(4) - np.dot(K, H), P), (np.identity(4) - np.dot(K, H)).T) 
    + np.dot(np.dot(K, R), K.T)
    #P = np.dot(np.identity(4) - np.dot(K, H), P)

    trajektorija = np.append(trajektorija, [x[0], x[1]])

    #print(t[i], x[0], x[1], sep ='\t')
    #print(t[i], P[0,0], P[0,2], P[2,2], sep='\t')

#print('')
print(trajektorija)
############################################# Nardim primerjavo
DATA = np.loadtxt("../kalman_cartesian_kontrola.dat", delimiter=" ")


T = DATA[:,0]
Z = np.c_[DATA[:,1], DATA[:,2]]
V = np.c_[DATA[:,3], DATA[:,4]]
n = len(t)
for i in range(1,n):
    dx1 = Z[i,0] - pozicija[i,0]
    dy1 = Z[i,1] - pozicija[i,1]
    dx2 = Z[i,0] - trajektorija[i,0]
    dy2 = Z[i,1] - trajektorija[i,1]
    print(t[i],dx1,dx2,dy2,dy2,sep='\t')
    #print(t[i],Z[i,0], Z[i,1], sep='\t')
print('')
